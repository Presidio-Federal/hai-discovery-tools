name: Network Discovery

env:
  # Default values for discovery parameters
  TIMEOUT: 60
  MAX_WAIT_TIME: 1800
  POLL_INTERVAL: 10
  CONCURRENCY: 200

on:
  workflow_dispatch:
    inputs:
      seed_devices:
        description: 'Comma-separated list of seed devices (IP:PORT)'
        required: true
        default: '192.168.1.1,10.0.0.1:22,172.16.1.1:4446'
      username:
        description: 'Primary username for device authentication'
        required: true
        default: 'admin'
      use_multiple_credentials:
        description: 'Use multiple credential sets'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      additional_usernames:
        description: 'Additional usernames (comma-separated, if multiple credentials enabled)'
        required: false
        default: 'cisco,operator'
      discovery_mode:
        description: 'Discovery mode to use'
        required: true
        default: 'full-pipeline'
        type: choice
        options:
          - full-pipeline
          - seed-device
          - subnet
      discovery_method:
        description: 'Discovery method to use (auto will select based on mode)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - neighbor_discovery
          - subnet_scan
          - ip_reachability
      max_depth:
        description: 'Maximum discovery depth'
        required: false
        default: '3'
      job_id:
        description: 'Custom job ID (optional)'
        required: false
      probe_ports:
        description: 'TCP ports to probe during reachability scan (comma-separated)'
        required: false
        default: '22,443'

jobs:
  run-discovery:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Pull the discovery service container
      - name: Pull discovery service container
        run: |
          docker pull ghcr.io/presidio-federal/hai-discovery-tools/discovery-service:latest
      
      # Start the discovery service
      - name: Start discovery service
        run: |
          # Check if container already exists and remove it
          if docker ps -a --format '{{.Names}}' | grep -q "^discovery-service$"; then
            echo "Found existing discovery-service container, removing it..."
            docker stop discovery-service || true
            docker rm discovery-service || true
          fi
          
          # Start the container
          echo "Starting discovery service container..."
          CONTAINER_ID=$(docker run -d --name discovery-service -p 8080:8080 ghcr.io/presidio-federal/hai-discovery-tools/discovery-service:latest)
          
          if [ -z "$CONTAINER_ID" ]; then
            echo "Failed to start discovery service container"
            exit 1
          fi
          
          echo "Container started with ID: $CONTAINER_ID"
          
          # Wait for service to start
          echo "Waiting for service to start..."
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -s http://localhost:8080/ > /dev/null; then
              echo "Service is up and running"
              break
            fi
            
            echo "Waiting for service to start (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
            sleep 2
            RETRY_COUNT=$((RETRY_COUNT+1))
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Service failed to start within the timeout period"
            docker logs discovery-service
            docker stop discovery-service || true
            docker rm discovery-service || true
            exit 1
          fi
          
          # Verify container is running
          if ! docker ps | grep -q discovery-service; then
            echo "Container is not running. Checking logs:"
            docker logs discovery-service
            exit 1
          fi
      
      # Install required tools
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      # Run discovery
      - name: Run discovery
        id: discovery
        run: |
          # Convert comma-separated list to JSON array
          SEED_DEVICES=$(echo "${{ github.event.inputs.seed_devices }}" | sed 's/,/","/g' | sed 's/^/["/g' | sed 's/$/"]/')
          
          # Prepare credentials
          if [ "${{ github.event.inputs.use_multiple_credentials }}" == "true" ]; then
            # Start with primary username
            USERNAMES=("${{ github.event.inputs.username }}")
            
            # Add additional usernames if provided
            if [ -n "${{ github.event.inputs.additional_usernames }}" ]; then
              IFS=',' read -r -a ADDITIONAL_USERNAMES <<< "${{ github.event.inputs.additional_usernames }}"
              USERNAMES+=("${ADDITIONAL_USERNAMES[@]}")
            fi
            
            # Get passwords from GitHub secrets
            # Format: DEVICE_PASSWORD for primary, ALT_DEVICE_PASSWORD_1, ALT_DEVICE_PASSWORD_2, etc. for additional
            PASSWORDS=("${{ secrets.DEVICE_PASSWORD }}")
            
            for i in "${!ADDITIONAL_USERNAMES[@]}"; do
              secret_name="ALT_DEVICE_PASSWORD_$((i+1))"
              # Try to dynamically access the secret
              password_var="secrets.${secret_name}"
              password="${!password_var}"
              if [ -n "$password" ]; then
                PASSWORDS+=("$password")
              else
                # Fallback to a generic alt password secret if specific one not found
                PASSWORDS+=("${{ secrets.ALT_DEVICE_PASSWORD }}")
              fi
            done
            
            # Build credentials JSON array
            CREDENTIALS="["
            for i in "${!USERNAMES[@]}"; do
              if [ $i -gt 0 ]; then
                CREDENTIALS="${CREDENTIALS},"
              fi
              CREDENTIALS="${CREDENTIALS}{\"username\": \"${USERNAMES[$i]}\", \"password\": \"${PASSWORDS[$i]}\"}"
            done
            CREDENTIALS="${CREDENTIALS}]"
            
            echo "Using ${#USERNAMES[@]} credential sets"
          else
            # Just use the primary username/password
            CREDENTIALS="[{\"username\": \"${{ github.event.inputs.username }}\", \"password\": \"${{ secrets.DEVICE_PASSWORD }}\"}]"
            echo "Using single credential set"
          fi
          
          # Process probe ports
          IFS=',' read -ra PORT_ARRAY <<< "${{ github.event.inputs.probe_ports }}"
          PROBE_PORTS="["
          for port in "${PORT_ARRAY[@]}"; do
            if [ "$PROBE_PORTS" != "[" ]; then
              PROBE_PORTS="$PROBE_PORTS,"
            fi
            PROBE_PORTS="$PROBE_PORTS$port"
          done
          PROBE_PORTS="$PROBE_PORTS]"
          
          # Set job ID if provided
          JOB_ID_PARAM=""
          if [ -n "${{ github.event.inputs.job_id }}" ]; then
            JOB_ID_PARAM="\"job_id\": \"${{ github.event.inputs.job_id }}\","
          fi
          
          # Start discovery - IMPORTANT: We're NOT using wait_for_results=true here
          # because we want to handle the waiting with proper polling
          echo "Starting discovery job..."
          RESPONSE=$(curl -s -X POST "http://localhost:8080/discover" \
            -H "Content-Type: application/json" \
            -d "{
              \"seed_devices\": $SEED_DEVICES,
              \"credentials\": $CREDENTIALS,
              \"mode\": \"${{ github.event.inputs.discovery_mode }}\",
              \"method\": \"${{ github.event.inputs.discovery_method }}\",
              \"max_depth\": ${{ github.event.inputs.max_depth }},
              \"timeout\": ${{ env.TIMEOUT }},
              $JOB_ID_PARAM
              \"probe_ports\": $PROBE_PORTS,
              \"concurrency\": ${{ env.CONCURRENCY }}
            }")
          
          echo "API response: $RESPONSE"
          
          # Check if jq is installed
          if ! command -v jq &> /dev/null; then
            echo "Error: jq is not installed. Using alternative method to extract job_id."
            # Extract job_id using grep and sed as fallback
            JOB_ID=$(echo $RESPONSE | grep -o '"job_id":"[^"]*"' | sed 's/"job_id":"//;s/"$//')
            if [ -z "$JOB_ID" ]; then
              echo "Failed to extract job_id from response. Exiting."
              exit 1
            fi
          else
            # Extract job ID using jq
            JOB_ID=$(echo $RESPONSE | jq -r '.job_id')
          fi
          
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" == "null" ]; then
            echo "Failed to get job ID from response:"
            echo $RESPONSE
            exit 1
          fi
          
          echo "Job ID: $JOB_ID"
          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
          
          # Create export directory
          mkdir -p discovery_exports
          
          # Wait for discovery to complete with timeout
          echo "Waiting for discovery job to complete..."
          MAX_WAIT_TIME=${{ env.MAX_WAIT_TIME }}  # Default: 30 minutes
          WAIT_INTERVAL=${{ env.POLL_INTERVAL }}    # Default: 10 seconds
          ELAPSED_TIME=0
          
          while [ $ELAPSED_TIME -lt $MAX_WAIT_TIME ]; do
            # Get job status
            STATUS_RESPONSE=$(curl -s "http://localhost:8080/discover/$JOB_ID")
            
            # Check if jq is installed
            if ! command -v jq &> /dev/null; then
              # Extract status using grep and sed as fallback
              JOB_STATUS=$(echo $STATUS_RESPONSE | grep -o '"status":"[^"]*"' | sed 's/"status":"//;s/"$//')
              if [ -z "$JOB_STATUS" ]; then
                JOB_STATUS="unknown"
              fi
            else
              # Extract job status using jq
              JOB_STATUS=$(echo $STATUS_RESPONSE | jq -r '.status')
            fi
            
            echo "Current status: $JOB_STATUS (waited ${ELAPSED_TIME}s)"
            
            # Check if job is complete
            if [ "$JOB_STATUS" == "completed" ] || [ "$JOB_STATUS" == "failed" ]; then
              break
            fi
            
            # Wait before checking again
            sleep $WAIT_INTERVAL
            ELAPSED_TIME=$((ELAPSED_TIME + WAIT_INTERVAL))
          done
          
          if [ $ELAPSED_TIME -ge $MAX_WAIT_TIME ]; then
            echo "Warning: Discovery job timed out after ${MAX_WAIT_TIME}s. Continuing with available data."
          else
            echo "Discovery job completed in ${ELAPSED_TIME}s."
          fi
          
          # Get summary information
          if command -v jq &> /dev/null; then
            SUMMARY=$(echo $STATUS_RESPONSE | jq -r '.summary // empty')
            if [ -n "$SUMMARY" ]; then
              echo "Discovery summary:"
              echo $SUMMARY | jq
            fi
          else
            echo "Discovery completed, but jq not available to parse summary."
          fi
      
      # Export discovery data
      - name: Export discovery data
        run: |
          JOB_ID="${{ steps.discovery.outputs.job_id }}"
          echo "Exporting data for job $JOB_ID..."
          
          # Export as JSON
          echo "Exporting JSON data..."
          curl -s --location --output discovery_exports/discovery_data.json "http://localhost:8080/discover/$JOB_ID/export?format=json"
          
          # Check if file exists and has content
          if [ ! -s discovery_exports/discovery_data.json ]; then
            echo "Warning: Empty or missing JSON data file"
            cat discovery_exports/discovery_data.json || echo "File not found"
          else
            echo "JSON data exported successfully"
            # Show file size
            ls -lh discovery_exports/discovery_data.json
            
            # Show device count if jq is available
            if command -v jq &> /dev/null; then
              echo "Discovered devices: $(jq '.devices | length' discovery_exports/discovery_data.json)"
            fi
          fi
          
          # Export device inventory
          echo "Exporting device inventory..."
          curl -s --location --output discovery_exports/device_inventory.csv "http://localhost:8080/discover/$JOB_ID/export/device_inventory"
          
          # Export interface inventory
          echo "Exporting interface inventory..."
          curl -s --location --output discovery_exports/interface_inventory.csv "http://localhost:8080/discover/$JOB_ID/export/interface_inventory"
          
          # Export topology visualization
          echo "Exporting topology visualization..."
          curl -s --location --output discovery_exports/topology.html "http://localhost:8080/discover/$JOB_ID/topology"
          
          # Export device configurations as ZIP
          echo "Exporting device configurations..."
          curl -s --location --output discovery_exports/configs.zip "http://localhost:8080/discover/$JOB_ID/export?format=configs"
          
          # Export reachability results
          echo "Exporting reachability results..."
          curl -s --location --output discovery_exports/reachability_matrix.json "http://localhost:8080/discover/$JOB_ID/reachability"
          
          # List all exported files
          echo "Exported files:"
          ls -lh discovery_exports/
      
      # Upload artifacts
      - name: Upload discovery results
        uses: actions/upload-artifact@v4
        with:
          name: discovery-results
          path: discovery_exports/
          retention-days: 7
      
      # Cleanup
      - name: Cleanup containers
        if: always()
        run: |
          echo "Cleaning up containers..."
          docker stop discovery-service || true
          docker rm discovery-service || true
          echo "Cleanup complete"
